// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: supp_org.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSuppOrg = `-- name: CreateSuppOrg :exec
INSERT INTO org_supporters (entity_type, entity_id, org_id, donation_amount, donation_date)
VALUES ($1, $2, $3, $4, NOW())
ON CONFLICT (entity_type, entity_id, org_id) DO UPDATE
    SET donation_amount = EXCLUDED.donation_amount, donation_date = NOW()
`

type CreateSuppOrgParams struct {
	EntityType     string
	EntityID       int64
	OrgID          int64
	DonationAmount pgtype.Numeric
}

func (q *Queries) CreateSuppOrg(ctx context.Context, arg CreateSuppOrgParams) error {
	_, err := q.db.Exec(ctx, createSuppOrg,
		arg.EntityType,
		arg.EntityID,
		arg.OrgID,
		arg.DonationAmount,
	)
	return err
}

const deleteSuppOrg = `-- name: DeleteSuppOrg :exec
delete from org_supporters
where entity_type = $1 and entity_id = $2 and org_id = $3
`

type DeleteSuppOrgParams struct {
	EntityType string
	EntityID   int64
	OrgID      int64
}

func (q *Queries) DeleteSuppOrg(ctx context.Context, arg DeleteSuppOrgParams) error {
	_, err := q.db.Exec(ctx, deleteSuppOrg, arg.EntityType, arg.EntityID, arg.OrgID)
	return err
}

const donateSumOrg = `-- name: DonateSumOrg :one
select org_id, sum(donation_amount) as total_donations
from org_supporters
where org_id = $1
group by org_id
`

type DonateSumOrgRow struct {
	OrgID          int64
	TotalDonations int64
}

func (q *Queries) DonateSumOrg(ctx context.Context, orgID int64) (DonateSumOrgRow, error) {
	row := q.db.QueryRow(ctx, donateSumOrg, orgID)
	var i DonateSumOrgRow
	err := row.Scan(&i.OrgID, &i.TotalDonations)
	return i, err
}

const getOrgByTopDonations = `-- name: GetOrgByTopDonations :many
SELECT o.org_id, o.name, SUM(os.donation_amount) as total_donated
FROM org_supporters os
         JOIN organizations o ON o.org_id = os.org_id
GROUP BY o.org_id, o.name
ORDER BY total_donated DESC
LIMIT 10
`

type GetOrgByTopDonationsRow struct {
	OrgID        int32
	Name         string
	TotalDonated int64
}

func (q *Queries) GetOrgByTopDonations(ctx context.Context) ([]GetOrgByTopDonationsRow, error) {
	rows, err := q.db.Query(ctx, getOrgByTopDonations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrgByTopDonationsRow
	for rows.Next() {
		var i GetOrgByTopDonationsRow
		if err := rows.Scan(&i.OrgID, &i.Name, &i.TotalDonated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSuppOrgByOrg = `-- name: GetSuppOrgByOrg :many
select entity_type, entity_id, org_id, donation_amount, donation_date
from org_supporters
where org_id = $1
`

func (q *Queries) GetSuppOrgByOrg(ctx context.Context, orgID int64) ([]OrgSupporter, error) {
	rows, err := q.db.Query(ctx, getSuppOrgByOrg, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrgSupporter
	for rows.Next() {
		var i OrgSupporter
		if err := rows.Scan(
			&i.EntityType,
			&i.EntityID,
			&i.OrgID,
			&i.DonationAmount,
			&i.DonationDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopSupportersForOrg = `-- name: GetTopSupportersForOrg :many
SELECT entity_type, entity_id, SUM(donation_amount) as total_donated
FROM org_supporters
WHERE org_id = $1
GROUP BY entity_type, entity_id
ORDER BY total_donated DESC
LIMIT 10
`

type GetTopSupportersForOrgRow struct {
	EntityType   string
	EntityID     int64
	TotalDonated int64
}

func (q *Queries) GetTopSupportersForOrg(ctx context.Context, orgID int64) ([]GetTopSupportersForOrgRow, error) {
	rows, err := q.db.Query(ctx, getTopSupportersForOrg, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSupportersForOrgRow
	for rows.Next() {
		var i GetTopSupportersForOrgRow
		if err := rows.Scan(&i.EntityType, &i.EntityID, &i.TotalDonated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSuppOrg = `-- name: ListSuppOrg :many
SELECT os.org_id, o.name, o.category, SUM(os.donation_amount) as total_donated
FROM org_supporters os
         JOIN organizations o ON o.org_id = os.org_id
WHERE os.entity_type = $1 AND os.entity_id = $2
GROUP BY os.org_id, o.name, o.category, o.category
`

type ListSuppOrgParams struct {
	EntityType string
	EntityID   int64
}

type ListSuppOrgRow struct {
	OrgID        int64
	Name         string
	Category     string
	TotalDonated int64
}

func (q *Queries) ListSuppOrg(ctx context.Context, arg ListSuppOrgParams) ([]ListSuppOrgRow, error) {
	rows, err := q.db.Query(ctx, listSuppOrg, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSuppOrgRow
	for rows.Next() {
		var i ListSuppOrgRow
		if err := rows.Scan(
			&i.OrgID,
			&i.Name,
			&i.Category,
			&i.TotalDonated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
