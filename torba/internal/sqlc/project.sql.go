// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: project.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProject = `-- name: CreateProject :one
insert into projects
(
 author_id, title, category, description, link,
 details, payments, funding_goal, created_at
) values ($1, $2,$3,$4,$5,$6,$7,$8,now())
returning project_id, author_id, title, category, description, link, details, payments, status, funding_goal, funds_raised, created_at, updated_at
`

type CreateProjectParams struct {
	AuthorID    int64
	Title       string
	Category    string
	Description string
	Link        string
	Details     string
	Payments    string
	FundingGoal pgtype.Numeric
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.AuthorID,
		arg.Title,
		arg.Category,
		arg.Description,
		arg.Link,
		arg.Details,
		arg.Payments,
		arg.FundingGoal,
	)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.AuthorID,
		&i.Title,
		&i.Category,
		&i.Description,
		&i.Link,
		&i.Details,
		&i.Payments,
		&i.Status,
		&i.FundingGoal,
		&i.FundsRaised,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProject = `-- name: DeleteProject :exec
delete from projects
where project_id = $1
returning project_id
`

func (q *Queries) DeleteProject(ctx context.Context, projectID int32) error {
	_, err := q.db.Exec(ctx, deleteProject, projectID)
	return err
}

const getProjectByAuthor = `-- name: GetProjectByAuthor :one
select project_id, author_id, title, category, description, link, details, payments, status, funding_goal, funds_raised, created_at, updated_at
from projects
where author_id = $1
`

func (q *Queries) GetProjectByAuthor(ctx context.Context, authorID int64) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByAuthor, authorID)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.AuthorID,
		&i.Title,
		&i.Category,
		&i.Description,
		&i.Link,
		&i.Details,
		&i.Payments,
		&i.Status,
		&i.FundingGoal,
		&i.FundsRaised,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectByCategory = `-- name: GetProjectByCategory :one
select project_id, author_id, title, category, description, link, details, payments, status, funding_goal, funds_raised, created_at, updated_at
from projects
where category = $1
`

func (q *Queries) GetProjectByCategory(ctx context.Context, category string) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByCategory, category)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.AuthorID,
		&i.Title,
		&i.Category,
		&i.Description,
		&i.Link,
		&i.Details,
		&i.Payments,
		&i.Status,
		&i.FundingGoal,
		&i.FundsRaised,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectByTitle = `-- name: GetProjectByTitle :one
select project_id, author_id, title, category, description, link, details, payments, status, funding_goal, funds_raised, created_at, updated_at
from projects
where title = $1
`

func (q *Queries) GetProjectByTitle(ctx context.Context, title string) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByTitle, title)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.AuthorID,
		&i.Title,
		&i.Category,
		&i.Description,
		&i.Link,
		&i.Details,
		&i.Payments,
		&i.Status,
		&i.FundingGoal,
		&i.FundsRaised,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listProjectAuthor = `-- name: ListProjectAuthor :many
select project_id, author_id, title, category, description, link, details, payments, status, funding_goal, funds_raised, created_at, updated_at from projects
order by author_id
`

func (q *Queries) ListProjectAuthor(ctx context.Context) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjectAuthor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ProjectID,
			&i.AuthorID,
			&i.Title,
			&i.Category,
			&i.Description,
			&i.Link,
			&i.Details,
			&i.Payments,
			&i.Status,
			&i.FundingGoal,
			&i.FundsRaised,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectCategory = `-- name: ListProjectCategory :many
select project_id, author_id, title, category, description, link, details, payments, status, funding_goal, funds_raised, created_at, updated_at from projects
order by category
`

func (q *Queries) ListProjectCategory(ctx context.Context) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjectCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ProjectID,
			&i.AuthorID,
			&i.Title,
			&i.Category,
			&i.Description,
			&i.Link,
			&i.Details,
			&i.Payments,
			&i.Status,
			&i.FundingGoal,
			&i.FundsRaised,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectID = `-- name: ListProjectID :many
select project_id, author_id, title, category, description, link, details, payments, status, funding_goal, funds_raised, created_at, updated_at from projects
order by project_id
`

func (q *Queries) ListProjectID(ctx context.Context) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ProjectID,
			&i.AuthorID,
			&i.Title,
			&i.Category,
			&i.Description,
			&i.Link,
			&i.Details,
			&i.Payments,
			&i.Status,
			&i.FundingGoal,
			&i.FundsRaised,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newestPrj = `-- name: NewestPrj :many
SELECT project_id, title, category, created_at
FROM projects
ORDER BY created_at DESC
LIMIT 10
`

type NewestPrjRow struct {
	ProjectID int32
	Title     string
	Category  string
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) NewestPrj(ctx context.Context) ([]NewestPrjRow, error) {
	rows, err := q.db.Query(ctx, newestPrj)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewestPrjRow
	for rows.Next() {
		var i NewestPrjRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.Title,
			&i.Category,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProject = `-- name: UpdateProject :one
update projects set
    title = $2,
    category = $3,
    description = $4,
    link = $5,
    details = $6,
    payments = $7,
    status = $8,
    funding_goal = $9,
    updated_at = now()
where project_id = $1
returning project_id, author_id, title, category, description, link, details, payments, status, funding_goal, funds_raised, created_at, updated_at
`

type UpdateProjectParams struct {
	ProjectID   int32
	Title       string
	Category    string
	Description string
	Link        string
	Details     string
	Payments    string
	Status      bool
	FundingGoal pgtype.Numeric
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProject,
		arg.ProjectID,
		arg.Title,
		arg.Category,
		arg.Description,
		arg.Link,
		arg.Details,
		arg.Payments,
		arg.Status,
		arg.FundingGoal,
	)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.AuthorID,
		&i.Title,
		&i.Category,
		&i.Description,
		&i.Link,
		&i.Details,
		&i.Payments,
		&i.Status,
		&i.FundingGoal,
		&i.FundsRaised,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
