// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: supp_project.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSuppPrj = `-- name: CreateSuppPrj :exec
INSERT INTO project_supporters (entity_type, entity_id, project_id, donation_amount, donation_date)
VALUES ($1, $2, $3, $4, NOW())
ON CONFLICT (entity_type, entity_id, project_id) DO UPDATE
SET donation_amount = EXCLUDED.donation_amount, donation_date = NOW()
`

type CreateSuppPrjParams struct {
	EntityType     string
	EntityID       int64
	ProjectID      int64
	DonationAmount pgtype.Numeric
}

func (q *Queries) CreateSuppPrj(ctx context.Context, arg CreateSuppPrjParams) error {
	_, err := q.db.Exec(ctx, createSuppPrj,
		arg.EntityType,
		arg.EntityID,
		arg.ProjectID,
		arg.DonationAmount,
	)
	return err
}

const deleteSuppPrj = `-- name: DeleteSuppPrj :exec
delete from project_supporters
where entity_type = $1 and entity_id = $2 and project_id = $3
`

type DeleteSuppPrjParams struct {
	EntityType string
	EntityID   int64
	ProjectID  int64
}

func (q *Queries) DeleteSuppPrj(ctx context.Context, arg DeleteSuppPrjParams) error {
	_, err := q.db.Exec(ctx, deleteSuppPrj, arg.EntityType, arg.EntityID, arg.ProjectID)
	return err
}

const donateSumPrj = `-- name: DonateSumPrj :one
select project_id, sum(donation_amount) as total_donations
from project_supporters
where project_id = $1
group by project_id
`

type DonateSumPrjRow struct {
	ProjectID      int64
	TotalDonations int64
}

func (q *Queries) DonateSumPrj(ctx context.Context, projectID int64) (DonateSumPrjRow, error) {
	row := q.db.QueryRow(ctx, donateSumPrj, projectID)
	var i DonateSumPrjRow
	err := row.Scan(&i.ProjectID, &i.TotalDonations)
	return i, err
}

const getProjectsByTopDonations = `-- name: GetProjectsByTopDonations :many
SELECT p.project_id, p.title, SUM(ps.donation_amount) as total_donated
FROM project_supporters ps
         JOIN projects p ON p.project_id = ps.project_id
GROUP BY p.project_id, p.title
ORDER BY total_donated DESC
LIMIT 10
`

type GetProjectsByTopDonationsRow struct {
	ProjectID    int32
	Title        string
	TotalDonated int64
}

func (q *Queries) GetProjectsByTopDonations(ctx context.Context) ([]GetProjectsByTopDonationsRow, error) {
	rows, err := q.db.Query(ctx, getProjectsByTopDonations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectsByTopDonationsRow
	for rows.Next() {
		var i GetProjectsByTopDonationsRow
		if err := rows.Scan(&i.ProjectID, &i.Title, &i.TotalDonated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSuppPrjByPrj = `-- name: GetSuppPrjByPrj :many
select entity_type, entity_id, project_id, donation_amount, donation_date
from project_supporters
where project_id = $1
`

func (q *Queries) GetSuppPrjByPrj(ctx context.Context, projectID int64) ([]ProjectSupporter, error) {
	rows, err := q.db.Query(ctx, getSuppPrjByPrj, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectSupporter
	for rows.Next() {
		var i ProjectSupporter
		if err := rows.Scan(
			&i.EntityType,
			&i.EntityID,
			&i.ProjectID,
			&i.DonationAmount,
			&i.DonationDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopSupportersForProject = `-- name: GetTopSupportersForProject :many
SELECT entity_type, entity_id, SUM(donation_amount) as total_donated
FROM project_supporters
WHERE project_id = $1
GROUP BY entity_type, entity_id
ORDER BY total_donated DESC
LIMIT 10
`

type GetTopSupportersForProjectRow struct {
	EntityType   string
	EntityID     int64
	TotalDonated int64
}

func (q *Queries) GetTopSupportersForProject(ctx context.Context, projectID int64) ([]GetTopSupportersForProjectRow, error) {
	rows, err := q.db.Query(ctx, getTopSupportersForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSupportersForProjectRow
	for rows.Next() {
		var i GetTopSupportersForProjectRow
		if err := rows.Scan(&i.EntityType, &i.EntityID, &i.TotalDonated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSuppPrj = `-- name: ListSuppPrj :many
SELECT ps.project_id, p.title, p.category, SUM(ps.donation_amount) as total_donated
FROM project_supporters ps
         JOIN projects p ON p.project_id = ps.project_id
WHERE ps.entity_type = $1 AND ps.entity_id = $2
GROUP BY ps.project_id, p.title, p.category
`

type ListSuppPrjParams struct {
	EntityType string
	EntityID   int64
}

type ListSuppPrjRow struct {
	ProjectID    int64
	Title        string
	Category     string
	TotalDonated int64
}

func (q *Queries) ListSuppPrj(ctx context.Context, arg ListSuppPrjParams) ([]ListSuppPrjRow, error) {
	rows, err := q.db.Query(ctx, listSuppPrj, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSuppPrjRow
	for rows.Next() {
		var i ListSuppPrjRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.Title,
			&i.Category,
			&i.TotalDonated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
